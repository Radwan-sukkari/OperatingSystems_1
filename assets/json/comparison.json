{
  "chapters": [
    {
      "id": 1,
      "title_en": "Chapter 1",
      "title_ar": "الفصل الأول",
      "Comparisons": [
        {
          "comparisonsHeight": 54.4,
          "firstColumnWidth": 75.4,
          "contentWidth": 75,
          "notes": "",
          "tableTitle": "المعماريات",
          "firstColumn": [
            "Monolithic \narchitecture",
            "Layered\narchitecture",
            "Microkernel\narchitecture"
          ],
          "mainColumnHeadings": [
            "الوصف",
            "الرسم"
          ],
          "rows": [
            [
              "كل مكونات نظام التشغيل موجودة \nفي الـ)Kernel )بحيث يستطيع أي \nُم ت\nَك واصل مع مكون أخر بشكل ِّون ال\nمباشر.\n- أداء سريع، ولكن يصعب تحديد \nمكان الخطأ إن وقع.",
              ""
            ],
            [
              "- يتم تقسيم الوظائف المتشابهة ضمن \nطبقة واحدة، تتواصل الطبقة مع \nالطبقة األعلى أو األدنى منها مباشرة \nفقط، وممكن أن تمر )Process)\nما خالل عدة طبقات قبل أن تكتمل.\n- أداء أبطأ، إنتاجية أقل من السابقة.",
              ""
            ],
            [
              "- الخدمات قليلة، بحيث تحافظ على \nِصغَر الـ)Kernel)، وقابلية \nو ِسعَ )رفع أو خفض أداء النظام الت ة\nبما بتناسب مع التطبيق(، وبالتالي \nقابلية التعديل عليها عالية، ولكن \nخفَّضت من الكفاءة",
              ""
            ]
          ]
        }
      ]
    },
    {
      "id": 4,
      "title_en": "Chapter 4",
      "title_ar": "الفصل الرابع",
      "Comparisons": [
        {
          "comparisonsHeight": 54.4,
          "firstColumnWidth": 75.4,
          "contentWidth": 75,
          "notes": "",
          "tableTitle": "النموذج",
          "firstColumn": [
            "user_level \nthreads",
            "kernal_level\nthreads",
            "comination\nuser_level\nand Kernel_\nlevel threads"
          ],
          "mainColumnHeadings": [
            "شرح",
            "ايجابيات",
            "سلبيات",
            "الرسم"
          ],
          "rows": [
            [
              "تنفذ عملياتها ضمن (user space) ولاتستطبع تنفيذ تعليمات ذات صلاحية معينة او الوصول الى موارد (kernal) بشكل مباشر ويقوم نظام التشغيل بتعيين كل ال (threads) ضمن (process) متعددة ",
              "1_اكثر محمولية\n 2-التزامن خارج ال (kernal) \n 3_مكتبات ال user level تستطيع جدولة threads الخاصة بها لتحسين الاداء ",
              "1_ترى ال kernal العملية المتعددة threads على انها threads وحيد ولايمكن جدولة العملية على اكثر من معالج ",
              ""
            ],
            [
              " 1_ تقوم بتعيين كل threads الى سياق تنفيذ خاص به  \n 2_ ليست دائما الحل الأفضل من أجل تطبيق متعدد ال (threads)",
              "1_ تزيد من ال (scalability)  \n 2_ التفاعل (interactivity)  \n 3 _الانتاجية (productivity)",
              "1_تزيد العبء (overhead) \n 2 _ تقلل المحمولية  (protability)",
              ""
            ],
            [
              "عدد ال (user level thread) وال (kernal level thread) ليس بالضرورة ان يكون متساوي ",
              " يخفف من العبء (overhead) مقارنة مع (one to one mapping) وذلك بتوظيف فكرة تجميع ال (threads) ",
              "",
              ""
            ]
          ]
        }
      ]
    },
    {
      "id": 5,
      "title_en": "Chapter 5",
      "title_ar": "الفصل الخامس",
      "Comparisons": [
        {
          "comparisonsHeight": 54.4,
          "firstColumnWidth": 75.4,
          "contentWidth": 75,
          "notes": "",
          "tableTitle": "النموذج",
          "firstColumn": [
            "Dekkers \nAlgorithm v1",
            "Dekkers\nAlgorithm v2",
            "Dekkers\nAlgorithm v3",
            "Dekkers\nAlgorithm v4",
            "Dekkers\nAlgorithm v5",
            "peterson\nAlgorithm"
          ],
          "mainColumnHeadings": [
            "ايجابيات",
            "سلبيات"
          ],
          "rows": [
            [
              "_نجح هذا الاصدار في فرض الاستبعاد المتادل\n_استخدم متحولات من أجل التحكم أي (thread) سوف ينفذ\n _ اعتمد على الفحصص المتكرر لمعرفة فيما اذا كانت المنطقة الحرجة متاحة أم لا عن طريق (busy waiting) ",
              "_ تسببت تفنية (busy waiting) باضاعة وقت مهم من وقت المعالج \n _ طهرت مشكلة (lock step \nsynchronization) اي تزامن قفل الخطوة وهو قفل مرحلي اذا دخل احد (thread) لايدخل الثاني"
            ],
            [
              "_ ازالت مشكلة lock step\n  syncchronization \n  _ فكت الارتباط :أصبح لكل thread متحول خاص به",
              " _ انتهكت الاستبعاد المتبادل \n _ يمكن ان يتقاطع ال thread اثناء تعديله لل flag \n _ اسوأ من الاول بفرض دخول كلا ال threads الى المنطقة الحرجة اي هناك تداخل"
            ],
            [
              "_ حلت مشكلة الاستبعاد المتبادل ( لايمكن ل 2 thread الدخول ) \n _ يهيى علم المنطقة الحرجة قبل فحص الدخول لها ",
              "_ احتمال لحدوث القفل الميت  dead lock \n _ لن يستطيع اي من ال thread كسر الحلقة \n _ ليست حلا لمشكلة الاستبعاد المتبادل"
            ],
            [
              "_ حلت المشاكل السابقة لاصدارات ديكر ( القفل الميت والاستبعاد المتبادل و busy waiting )",
              "_ ولدت مشكلة الانتظار غير المسمى ( وهذا غير مقبول في انظمة العمل الحرجة)"
            ],
            [
              "- تسمى خوارزمية ديكر للاستبعاد المتبادل \n _ الحل المناسب الذي يضمن الاستبعاد المتبادل\n _ تستخدم مفهوم ال thread المفضل للدخول للمنطقة الحرجة \n _ حلت مشكة من سينفذ اولا \n _ يتجنب المشاكل السابقة القفل الميت والانتظار الغير مسمى",
              ""
            ],
            [
              "_ اقل تعقيدا من خوارزمية ديكر \n _ تعتمد على ال favoured thread & busy waiting \n _ خطواتها أقل في تنفيذ الاستبعاد المتبادل \n _ تتجنب مشاكل ( Postponement & deadlock)",
              ""
            ]
          ]
        }
      ]
    }
  ]
}